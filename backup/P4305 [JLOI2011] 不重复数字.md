# P4305 [JLOI2011] 不重复数字

## 题目描述

给定 $n$ 个数，要求把其中重复的去掉，只保留第一次出现的数。

## 输入格式

**本题有多组数据。**

第一行一个整数 $T$，表示数据组数。

对于每组数据：

第一行一个整数 $n$。

第二行 $n$ 个数，表示给定的数。

## 输出格式

对于每组数据，输出一行，为去重后剩下的数，两个数之间用一个空格隔开。

## 输入输出样例 #1

### 输入 #1

```
2
11
1 2 18 3 3 19 2 3 6 5 4
6
1 2 3 4 5 6
```

### 输出 #1

```
1 2 18 3 19 6 5 4
1 2 3 4 5 6
```

## 说明/提示

对于 $30\%$ 的数据，$n \le 100$，给出的数 $\in [0, 100]$。

对于 $60\%$ 的数据，$n \le 10^4$，给出的数 $\in [0, 10^4]$。

对于 $100\%$ 的数据，$1 \le T\le 50$，$1 \le n \le 5 \times 10^4$，给出的数在 $32$ 位有符号整数范围内。



# 解法

先说暴力解法，每次插入数字时遍历所有已插入的数字，如果有重复则放弃插入，然后输出，时间复杂度为**O(n)**

那么，如果使用一个表记录所有插入过的数字，之后插入的时候遍历，如果表中已有则放弃插入，就能完成部分状况下的优化，但是一些剧毒数据（比如1 2 3 4 5 5 5 5 5 5 ...）的时间复杂度依旧会很高

此时想到，如果能加快查表速度，是不是就能解决这个问题呢，能够根据索引直接访问的数组显然可以做到（直接让索引值等于数据值），但是由于题目给的数据范围过大，根本没有那么大的数组可供使用（实际上还得考虑负数数据）

考虑到数据范围远大于数据数量，也就是说数据在范围和数量上具有“稀疏”的特性，于是便想到了哈希表，直接令键值等于最大数据数目（50000），拉链法存储就能解决了

```cpp
//链结点声明，data初始化为187415157（没法初始化成null，只能祈祷不会中奖）
typedef struct node{
	int data;
	node* next;

        //当时为了让下标对应，链表没有设计头结点，所以要好好初始化防止第一个结点判断出错（但实际上根本没必要对应下标，当时没想到）
	node() : data(187415157), next(NULL){}
}*sequence, node;

int main() {
        //所有数据使用了一个动态分配的二维数组S存储，哈希表为动态分配的二维数组H，以及输入数据，
	int T, ** S, n, culData, *N;
	node ** H, *culNode;

	scanf("%d", &T);
	S = new int* [T];
	H = new node* [T];
	N = new int [T];

	for (int i = 0; i < T; i++) {
		scanf("%d", &n);
		S[i] = new int [n];
		H[i] = new node[n];
		
		int k = 0;
		for (int j = 0; j < n; j++) {
                        //插入数据时，值映射到键的时候要注意考虑负数情况，因为这个RE了，另外判断链表是否为空，若为空直接插入
			scanf("%d", &culData);
			int flag = 0;
			culNode = &H[i][ (culData % n + n) % n ];
			if (culNode->data == 187415157) {
				culNode->data = culData;
				culNode->next = NULL;
				S[i][k++] = culData;
			}
			
                        //遍历链表，使用flag来记录是否重复，若不重复则将数据插入链表
			while (culNode) {
				if (culNode->data == culData) {
					flag = 1;
					break;
				}

				else if (culNode->next == NULL) {
					flag = 0;
					culNode->next = new node;
					culNode->next->data = culData;
					culNode->next->next = NULL;
					break;
				}

				culNode = culNode->next;
			}

			if (flag == 0) S[i][k++] = culData;
		}
                
                //记录一下每个数组有多少个不重复的数据
		N[i] = k;
	}

	for (int i = 0; i < T; i++) {
		for (int j = 0; j < N[i]; j++) {
			cout << S[i][j] << " " ;
		}
		cout << endl;
	}


	return 0;
}
```



就这个哈希表解决的题我写了一下午，然后debug了一晚上，期间因为各种逻辑错误（比如映射到键忘记考虑负数，忘记考虑存储不同组数据的不重复数据数，因为没有头结点导致的各种边界条件问题）导致卡了好久，问腾讯元宝也问不出来，反倒是真DS帮我看出了问题，现在重新再审视代码发现没有多难，还是自己水平不够了，还是得多多精进呢= =、

写的时候就在想，哈希表有没有标准库能直接用的（是的，ds说有，题解的大佬们也用了，可恶），事后发现真的有，如果学过的话就能省很多时间了，可是学习真的不如自己上手做有意思啊kora！！！(╯‵□′)╯︵┻━┻，好吧还是得好好学习，还有下次记得用头结点- -、